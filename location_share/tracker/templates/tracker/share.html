<!-- tracker/templates/tracker/share.html -->
{% extends 'tracker/base.html' %}
{% csrf_token %}
{% block title %}チョイシェアMAP{% endblock %}

{% block content %}
<div class="row">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">
                    <i class="fas fa-map-marker-alt"></i> 位置情報共有マップ
                </h5>
                <div>
                    <small class="text-muted">残り時間: </small>
                    <span id="countdown" class="countdown"></span>
                </div>
            </div>
            <div class="card-body p-0">
                <div id="map" class="map-container"></div>
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-cog"></i> 設定
                </h6>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <label for="participant-name" class="form-label">表示名（30文字以内）</label>
                        <input type="text" class="form-control" id="participant-name" placeholder="例: 田中太郎">
                    </div>
                    <div class="col-md-6">
                        <label class="form-label">位置情報共有</label>
                        <div>
                            <button id="toggle-sharing" class="btn btn-success">
                                <i class="fas fa-play"></i> 共有開始
                            </button>
                            <button id="reset-view" class="btn btn-info ms-2">
                                <i class="fas fa-expand-arrows-alt"></i> 全体表示
                            </button>
                            <button id="leave-session" class="btn btn-danger ms-2">
                                <i class="fas fa-sign-out-alt"></i> 退出
                            </button>
                        </div>
                    </div>
                </div>
                <div class="mt-2">
                    <small class="text-muted">
                        位置情報ステータス: <span id="location-status">待機中</span>
                    </small>
                </div>
                <div class="mt-1">
                    <small class="text-muted">
                        表示状態: <span id="visibility-status">アクティブ</span>
                    </small>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-4">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-users"></i> 参加者リスト
                </h6>
            </div>
            <div class="card-body">
                <div id="participants-list" class="participant-list">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>読み込み中...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-3">
            <div class="card-header">
                <h6 class="mb-0">
                    <i class="fas fa-info-circle"></i> 共有情報
                </h6>
            </div>
            <div class="card-body">
                <div class="mb-2">
                    <small class="text-muted">セッションID</small>
                    <div class="font-monospace small">{{ session.session_id }}</div>
                </div>
                <div class="mb-2">
                    <small class="text-muted">有効期限</small>
                    <div>{{ expires_at|date:"Y/m/d H:i" }}</div>
                </div>
                <div class="mb-2">
                    <small class="text-muted">共有時間</small>
                    <div>{{ session.duration_minutes }}分</div>
                </div>
                <div class="mb-2">
                    <small class="text-muted">ステータス</small>
                    <div id="session-status">
                        <span class="badge bg-success">アクティブ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 権限要求モーダル -->
<div class="modal fade" id="permission-modal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">位置情報の利用許可</h5>
            </div>
            <div class="modal-body">
                <p>位置情報を共有するには、ブラウザの位置情報アクセス許可が必要です。</p>
                <p>「許可」をクリックして位置情報の利用を許可してください。</p>
                <div class="alert alert-info">
                    <small>
                        <i class="fas fa-info-circle"></i>
                        ブラウザがバックグラウンドになると、オフライン表示に切り替わります。
                    </small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" onclick="requestLocation()">許可する</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">キャンセル</button>
            </div>
        </div>
    </div>
</div>

<!-- セッション期限切れモーダル -->
<div class="modal fade" id="session-expired-modal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-danger">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title">
                    <i class="fas fa-exclamation-triangle me-2"></i>セッション期限切れ
                </h5>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning mb-3">
                    <i class="fas fa-clock me-2"></i>
                    このセッションは期限切れになりました。
                </div>
                <p class="mb-3">位置情報の共有が自動的に停止されました。</p>
                <p class="mb-0 text-muted">
                    <i class="fas fa-info-circle me-1"></i>
                    新しいセッションを作成するには、トップページに戻ってください。
                </p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" onclick="goToHome()">
                    <i class="fas fa-home me-1"></i>トップページへ
                </button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="geolocation-unsupported-modal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content border-warning">
            <div class="modal-header bg-warning text-dark">
                <h5 class="modal-title">
                    <i class="fas fa-exclamation-triangle me-2"></i>位置情報未対応
                </h5>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning mb-3">
                    <i class="fas fa-mobile-alt me-2"></i>
                    このブラウザでは位置情報がサポートされていません。
                </div>
                <p class="mb-3">位置情報を共有するには、以下のブラウザをお使いください：</p>
                <ul class="mb-3">
                    <li>Chrome (推奨)</li>
                    <li>Firefox</li>
                    <li>Safari</li>
                    <li>Edge</li>
                </ul>
                <p class="mb-0 text-muted">
                    <i class="fas fa-info-circle me-1"></i>
                    また、HTTPSでアクセスしている必要があります。
                </p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">
                    <i class="fas fa-check me-1"></i>確認
                </button>
            </div>
        </div>
    </div>
</div>
<div class="card-body">
    <!-- 既存のコンテンツの後に追加 -->
    <div class="mt-3">
        <div class="row">
            <div class="col-md-6">
                <small class="text-muted">WebSocket接続状態</small>
                <div id="websocket-status" class="fw-bold">
                    <span class="badge bg-secondary">未接続</span>
                </div>
            </div>
            <div class="col-md-6">
                <small class="text-muted">最後の通信</small>
                <div id="last-communication" class="fw-bold text-muted">-</div>
            </div>
        </div>
    </div>
</div>
<style>
.custom-marker {
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    border: 2px solid white;
    position: relative;
}

.custom-marker::before {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid white;
}

#location-status {
    font-weight: bold;
}

.status-active {
    color: #28a745;
}

.status-background {
    color: #6c757d;
}

.status-error {
    color: #dc3545;
}

.status-waiting {
    color: #ffc107;
}

#visibility-status {
    font-weight: bold;
}

.visibility-active {
    color: #28a745;
}

.visibility-background {
    color: #6c757d;
}

.participant-item {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    padding: 8px;
    border: 1px solid #e9ecef;
    border-radius: 5px;
    background-color: #f8f9fa;
}

.status-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 10px;
    flex-shrink: 0;
}

.status-online {
    background-color: #28a745;
    box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3);
}

.status-offline {
    background-color: #dc3545;
}

.status-background {
    background-color: #6c757d;
}
.connection-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 5px;
    animation: pulse 2s infinite;
}

.connection-good {
    background-color: #28a745;
}

.connection-poor {
    background-color: #ffc107;
}

.connection-bad {
    background-color: #dc3545;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

.realtime-notification {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    max-width: 300px;
}

.ping-indicator {
    font-size: 0.8em;
    color: #6c757d;
}
/* 待機中ステータス用のスタイル */
.status-waiting {
    box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.3);
    animation: pulse-waiting 2s infinite;
}

@keyframes pulse-waiting {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(255, 193, 7, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 193, 7, 0);
    }
}
.following-participant {
    background-color: rgba(13, 202, 240, 0.1);
    border-left: 3px solid #0dcaf0;
}
</style>
{% endblock %}

{% block extra_js %}
<script>
    // === 基本変数 ===
    let participantOrder = [];
    let lastAnimationTime = {};
    let websocket = null;
    let map;
    let markers = {};
    let accuracyCircles = {};
    let animationCircles = {};
    let watchId;
    let isSharing = false;
    let sessionExpired = false;
    let mapInitialized = false;
    let participantColors = {};
    let participantsData = [];
    let userInteracted = false;
    let autoFitEnabled = true;
    let lastKnownPosition = null;
    let isInBackground = false;
    let currentParticipantsHtml = '';
    let eventListeners = [];
    let markerUpdateQueue = new Map();
    let regularAnimationIntervals = {};
    let connectionInterval = null;
    let locationInterval = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    let backgroundReconnectAttempts = 0;

    // === DOM要素キャッシュ ===
    let elements = {};

    // === 設定値の簡素化 ===
    const CONFIG = {
        CONNECTION_CHECK_INTERVAL: 15000,
        LOCATION_TIMEOUT: 10000,
        RECONNECT_BASE_DELAY: 2000,
        RECONNECT_MAX_DELAY: 30000,
        RECONNECT_MULTIPLIER: 1.5,
        PARTICIPANTS_UPDATE: 1000,
        MOVEMENT_THRESHOLD: 10,
        MIN_TIME_BETWEEN_UPDATES: 3000,
        MAX_TIME_WITHOUT_UPDATE: 45000,
        BACKGROUND_UPDATE_INTERVAL: 60000,
        POSITION_CACHE_DURATION: 300000,
    };

    // === 状態保存用の変数 ===
    let backgroundLocationUpdate = null;
    let lastSuccessfulConnection = null;
    let isReconnecting = false;
    let sessionState = {
        isSharing: false,
        participantName: '',
        lastPosition: null,
        sharingStartTime: null
    };

    // === 追従対象管理用変数 ===
    let followingParticipantId = null;

    // === セッション情報 ===
    const sessionId = '{{ session.session_id }}';
    const participantId = '{{ participant_id }}';
    const expiresAt = new Date('{{ expires_at|date:"c" }}');

    // === 移動検知用変数 ===
    let lastSentPosition = null;
    let lastSentTime = 0;
    let forcedUpdateTimeout = null;

    // === LocalStorage キー定数 ===
    const STORAGE_KEYS = {
        SESSION_STATE: `locationSharing_${sessionId}_${participantId}`,
        PARTICIPANT_NAME: `participantName_${sessionId}_${participantId}`,
        LAST_POSITION: `lastPosition_${sessionId}_${participantId}`
    };

    // === 状態管理の改善 ===
    function saveSessionState() {
        try {
            const stateToSave = {
                isSharing: isSharing,
                participantName: elements.participantName?.value || '',
                lastPosition: lastKnownPosition ? {
                    latitude: lastKnownPosition.coords.latitude,
                    longitude: lastKnownPosition.coords.longitude,
                    accuracy: lastKnownPosition.coords.accuracy,
                    timestamp: Date.now()
                } : null,
                sharingStartTime: sessionState.sharingStartTime,
                savedAt: Date.now()
            };
            
            localStorage.setItem(STORAGE_KEYS.SESSION_STATE, JSON.stringify(stateToSave));
            console.log('状態を保存しました:', stateToSave);
        } catch (error) {
            console.warn('状態保存に失敗:', error);
        }
    }

    function loadSessionState() {
        try {
            const savedState = localStorage.getItem(STORAGE_KEYS.SESSION_STATE);
            if (!savedState) return null;

            const state = JSON.parse(savedState);
            const timeSinceSaved = Date.now() - (state.savedAt || 0);
            
            // 5分以内の状態のみ復元
            if (timeSinceSaved > CONFIG.POSITION_CACHE_DURATION) {
                console.log('保存状態が古いため無視します');
                clearSessionState();
                return null;
            }

            console.log('保存状態を読み込みました:', state);
            return state;
        } catch (error) {
            console.warn('状態読み込みに失敗:', error);
            clearSessionState();
            return null;
        }
    }

    function clearSessionState() {
        try {
            localStorage.removeItem(STORAGE_KEYS.SESSION_STATE);
            localStorage.removeItem(STORAGE_KEYS.PARTICIPANT_NAME);
            localStorage.removeItem(STORAGE_KEYS.LAST_POSITION);
        } catch (error) {
            console.warn('状態クリアに失敗:', error);
        }
    }

    // === イベントリスナー管理 ===
    function addEventListenerWithCleanup(element, event, handler, options = {}) {
        if (element) {
            element.addEventListener(event, handler, options);
            eventListeners.push({ element, event, handler, options });
        }
    }

    function cleanupEventListeners() {
        eventListeners.forEach(({ element, event, handler, options }) => {
            if (element && element.removeEventListener) {
                element.removeEventListener(event, handler, options);
            }
        });
        eventListeners = [];
    }

    // === DOM要素の初期化 ===
    function initElements() {
        elements = {
            wsStatus: document.getElementById('websocket-status'),
            locationStatus: document.getElementById('location-status'),
            visibilityStatus: document.getElementById('visibility-status'),
            participantsList: document.getElementById('participants-list'),
            countdown: document.getElementById('countdown'),
            participantName: document.getElementById('participant-name'),
            toggleSharing: document.getElementById('toggle-sharing'),
            sessionStatus: document.getElementById('session-status'),
            lastCommunication: document.getElementById('last-communication')
        };
    }

    // === 統合されたステータス更新 ===
    function updateStatus(type, status, message) {
        const element = elements[type + 'Status'];
        if (!element) return;

        switch (type) {
            case 'ws':
                let badgeClass = 'bg-secondary';
                let indicator = '';
                switch(status) {
                    case 'connected':
                        badgeClass = 'bg-success';
                        indicator = '<span class="connection-indicator connection-good"></span>';
                        break;
                    case 'reconnecting':
                        badgeClass = 'bg-warning';
                        indicator = '<span class="connection-indicator connection-poor"></span>';
                        break;
                    case 'error':
                    case 'disconnected':
                        badgeClass = 'bg-danger';
                        indicator = '<span class="connection-indicator connection-bad"></span>';
                        break;
                }
                element.innerHTML = `${indicator}<span class="badge ${badgeClass}">${message}</span>`;
                break;
            case 'location':
            case 'visibility':
                element.textContent = message;
                element.className = `status-${status}`;
                break;
        }
    }

    // === 通知表示 ===
    function showNotification(message, type = 'info') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type} alert-dismissible fade show realtime-notification`;
        alertDiv.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        
        document.body.appendChild(alertDiv);
        
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
            }
        }, 5000);
    }

    // === 統合された接続管理 ===
    function startConnectionManagement() {
        if (connectionInterval) clearInterval(connectionInterval);
        
        connectionInterval = setInterval(() => {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                if (!isReconnecting) {
                    console.warn('WebSocket接続が無効 - 再接続試行');
                    initWebSocket();
                }
                return;
            }

            const timeSinceLastSuccess = Date.now() - (lastSuccessfulConnection || 0);
            if (timeSinceLastSuccess > CONFIG.CONNECTION_CHECK_INTERVAL * 2) {
                console.warn('長時間通信なし - 接続確認');
            }

            const pingData = {
                type: 'ping',
                participant_id: participantId,
                timestamp: Date.now(),
                is_sharing: isSharing,
                has_position: !!lastKnownPosition
            };
            
            try {
                websocket.send(JSON.stringify(pingData));
                if (elements.lastCommunication) {
                    elements.lastCommunication.textContent = new Date().toLocaleTimeString() + ' (ping)';
                }
            } catch (error) {
                console.error('Ping送信エラー:', error);
                if (!isReconnecting) {
                    initWebSocket();
                }
            }
        }, CONFIG.CONNECTION_CHECK_INTERVAL);
    }

    function stopConnectionManagement() {
        if (connectionInterval) {
            clearInterval(connectionInterval);
            connectionInterval = null;
        }
    }

    // === WebSocket初期化（修正版） ===
    function initWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/location/${sessionId}/`;
    
    if (websocket) {
        websocket.close();
        websocket = null;
    }
    
    isReconnecting = true;
    
    try {
        websocket = new WebSocket(wsUrl);
        
        websocket.onopen = function(event) {
            console.log('WebSocket接続確立');
            reconnectAttempts = 0;
            backgroundReconnectAttempts = 0;
            isReconnecting = false;
            lastSuccessfulConnection = Date.now();
            
            updateStatus('ws', 'connected', '接続中');
            startConnectionManagement();
            
            // 参加通知（状態を正確に送信）
            const joinMessage = {
                type: 'join',
                participant_id: participantId,
                participant_name: sessionState.participantName || elements.participantName?.value || '',
                is_sharing: isSharing,
                has_cached_position: !!lastKnownPosition,
                // 初回参加時は待機状態として明確に示す
                initial_status: isSharing ? 'sharing' : 'waiting'
            };
            websocket.send(JSON.stringify(joinMessage));
            
            // 位置共有中の場合のみ位置情報を送信
            if (isSharing && lastKnownPosition) {
                console.log('復帰時の位置情報を送信');
                sendLocationUpdate(lastKnownPosition);
            }
            // 注意: 共有停止中の場合はoffline通知を送信しない
            // 待機状態として扱う
        };
        
        websocket.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
                lastSuccessfulConnection = Date.now();
            } catch (error) {
                console.error('メッセージ解析エラー:', error);
            }
        };
        
        websocket.onclose = function(event) {
            console.log('WebSocket接続切断:', event.code, event.reason);
            updateStatus('ws', 'disconnected', '切断');
            stopConnectionManagement();
            isReconnecting = false;
            
            if (!sessionExpired) {
                const maxAttempts = isInBackground ? 5 : maxReconnectAttempts;
                const currentAttempts = isInBackground ? backgroundReconnectAttempts : reconnectAttempts;
                
                if (currentAttempts < maxAttempts) {
                    if (isInBackground) {
                        backgroundReconnectAttempts++;
                    } else {
                        reconnectAttempts++;
                    }
                    
                    const delay = Math.min(
                        CONFIG.RECONNECT_BASE_DELAY * Math.pow(CONFIG.RECONNECT_MULTIPLIER, currentAttempts),
                        CONFIG.RECONNECT_MAX_DELAY
                    );
                    
                    console.log(`再接続試行 ${currentAttempts + 1}/${maxAttempts} (${delay}ms後, background: ${isInBackground})`);
                    updateStatus('ws', 'reconnecting', `再接続中 (${currentAttempts + 1}/${maxAttempts})`);
                    
                    setTimeout(initWebSocket, delay);
                } else {
                    console.warn('最大再接続試行回数に達しました');
                    updateStatus('ws', 'error', 'エラー - 再試行上限');
                    
                    if (isInBackground) {
                        console.log('バックグラウンドでの再接続を停止。フォアグラウンド復帰時に再開します。');
                    }
                }
            }
        };
        
        websocket.onerror = function(error) {
            console.error('WebSocketエラー:', error);
            updateStatus('ws', 'error', 'エラー');
            isReconnecting = false;
        };
        
    } catch (error) {
        console.error('WebSocket初期化エラー:', error);
        updateStatus('ws', 'error', 'エラー');
        isReconnecting = false;
    }
}

    // === メッセージハンドラー ===
    function handleWebSocketMessage(data) {
    switch (data.type) {
        case 'location_update':
            if (data.locations) {
                // 即座にマーカーと参加者リストを更新
                updateMapMarkers(data.locations);
                updateParticipantsList(data.locations);
                participantsData = data.locations;
            }
            break;
        case 'background_status_change':
            if (data.locations) {
                // 即座にマーカーと参加者リストを更新
                updateMapMarkers(data.locations);
                updateParticipantsList(data.locations);
                participantsData = data.locations;
                console.log(`参加者 ${data.participant_name || data.participant_id} のバックグラウンド状態が変更されました`);
            }
            break;
        case 'session_expired':
            handleSessionExpired();
            break;
        case 'error':
            if (data.message.includes('期限切れ')) {
                handleSessionExpired();
            }
            break;
        case 'pong':
            // Ping応答を受信
            if (elements.lastCommunication) {
                elements.lastCommunication.textContent = new Date().toLocaleTimeString() + ' (pong)';
            }
            break;
    }
}

    // === 位置情報管理（修正版） ===
    function startLocationSharing() {
    if (!navigator.geolocation) {
        updateStatus('location', 'error', 'このブラウザでは位置情報がサポートされていません');
        return;
    }

    // 状態を保存
    sessionState.isSharing = true;
    sessionState.sharingStartTime = Date.now();
    sessionState.participantName = elements.participantName?.value || '';

    // 移動検知用変数を初期化
    lastSentPosition = null;
    lastSentTime = 0;
    if (forcedUpdateTimeout) {
        clearTimeout(forcedUpdateTimeout);
        forcedUpdateTimeout = null;
    }

    updateStatus('location', 'waiting', '位置情報を取得中...');
    
    const options = {
        enableHighAccuracy: true,
        timeout: CONFIG.LOCATION_TIMEOUT,
        maximumAge: 2000
    };
    
    // 初回取得
    navigator.geolocation.getCurrentPosition(
        function(position) {
            lastKnownPosition = position;
            sessionState.lastPosition = {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: Date.now()
            };
            
            sendLocationUpdate(position);
            lastSentPosition = position;
            lastSentTime = Date.now();
            
            updateStatus('location', 'active', '位置情報を共有中');
            startLocationTracking();
            startBackgroundLocationUpdate();
            
            // 状態を保存
            saveSessionState();
        },
        function(error) {
            handleLocationError(error);
        },
        options
    );
    
    isSharing = true;
    updateSharingButton();
}

    function startBackgroundLocationUpdate() {
        if (backgroundLocationUpdate) {
            clearInterval(backgroundLocationUpdate);
        }
        
        backgroundLocationUpdate = setInterval(() => {
            if (isInBackground && isSharing && lastKnownPosition) {
                console.log('バックグラウンド位置更新');
                sendLocationUpdate(lastKnownPosition);
            }
        }, CONFIG.BACKGROUND_UPDATE_INTERVAL);
    }

    function stopBackgroundLocationUpdate() {
        if (backgroundLocationUpdate) {
            clearInterval(backgroundLocationUpdate);
            backgroundLocationUpdate = null;
        }
    }

    function startLocationTracking() {
        if (watchId) {
            navigator.geolocation.clearWatch(watchId);
        }
        
        watchId = navigator.geolocation.watchPosition(
            function(position) {
                lastKnownPosition = position;
                updateStatus('location', 'active', '位置情報を共有中');
                
                // 状態を定期的に保存
                saveSessionState();
                
                if (shouldSendUpdate(position)) {
                    sendLocationUpdate(position);
                    lastSentPosition = position;
                    lastSentTime = Date.now();
                    
                    if (forcedUpdateTimeout) {
                        clearTimeout(forcedUpdateTimeout);
                        forcedUpdateTimeout = null;
                    }
                }
                
                if (!forcedUpdateTimeout) {
                    forcedUpdateTimeout = setTimeout(() => {
                        if (lastKnownPosition) {
                            sendLocationUpdate(lastKnownPosition);
                            lastSentPosition = lastKnownPosition;
                            lastSentTime = Date.now();
                        }
                        forcedUpdateTimeout = null;
                    }, CONFIG.MAX_TIME_WITHOUT_UPDATE);
                }
            },
            function(error) {
                console.warn('位置情報監視エラー:', error);
            },
            {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 1000
            }
        );
    }

    // === 共有停止の修正 ===
    function stopLocationSharing() {
    console.log('位置情報共有を停止中...');
    
    // 監視を停止
    if (watchId) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
    }
    
    if (locationInterval) {
        clearInterval(locationInterval);
        locationInterval = null;
    }
    
    stopBackgroundLocationUpdate();
    
    if (forcedUpdateTimeout) {
        clearTimeout(forcedUpdateTimeout);
        forcedUpdateTimeout = null;
    }
    
    // 移動検知用変数をリセット
    lastSentPosition = null;
    lastSentTime = 0;
    
    // 状態を更新
    sessionState.isSharing = false;
    sessionState.sharingStartTime = null;
    isSharing = false;
    
    // 自分のマーカーを即座に削除
    removeOwnMarker();
    
    // 共有停止通知を送信（待機状態に戻す）
    if (websocket && websocket.readyState === WebSocket.OPEN) {
        const stopSharingData = {
            type: 'stop_sharing',
            participant_id: participantId,
            participant_name: elements.participantName?.value || '',
            is_background: isInBackground,
            // 確実に位置情報をクリアするためのフラグ
            clear_location: true,
            timestamp: new Date().toISOString()
        };
        
        console.log('共有停止通知を送信 (background:', isInBackground, '):', stopSharingData);
        websocket.send(JSON.stringify(stopSharingData));
        
        // バックグラウンド状態の場合は追加で確認メッセージを送信
        if (isInBackground) {
            setTimeout(() => {
                if (websocket && websocket.readyState === WebSocket.OPEN && !isSharing) {
                    const confirmData = {
                        type: 'confirm_stop_sharing',
                        participant_id: participantId,
                        participant_name: elements.participantName?.value || '',
                        is_background: true,
                        timestamp: new Date().toISOString()
                    };
                    websocket.send(JSON.stringify(confirmData));
                    console.log('バックグラウンド共有停止確認を送信');
                }
            }, 1000);
        }
    }
    
    // UIを更新
    updateSharingButton();
    updateStatus('location', 'waiting', '待機中');
    
    // 状態を保存
    saveSessionState();
    
    console.log('位置情報共有を停止しました - 待機状態に変更 (background:', isInBackground, ')');
}

    // === 自分のマーカーを削除する関数 ===
    function removeOwnMarker() {
    console.log('自分のマーカーを削除中:', participantId, 'background:', isInBackground);
    
    // 定期アニメーションを停止
    stopRegularAnimation(participantId);
    
    // マーカーを削除
    if (markers[participantId]) {
        map.removeLayer(markers[participantId]);
        delete markers[participantId];
        console.log('マーカーを削除しました');
    }
    
    // 精度円を削除
    if (accuracyCircles[participantId]) {
        map.removeLayer(accuracyCircles[participantId]);
        delete accuracyCircles[participantId];
        console.log('精度円を削除しました');
    }
    
    // アニメーション円を削除
    if (animationCircles[participantId]) {
        map.removeLayer(animationCircles[participantId]);
        delete animationCircles[participantId];
        console.log('アニメーション円を削除しました');
    }
    
    // 参加者データからも位置情報を削除
    participantsData = participantsData.map(p => {
        if (p.participant_id === participantId) {
            return {
                ...p,
                latitude: null,
                longitude: null,
                accuracy: null,
                status: 'waiting',  // 待機状態に設定
                is_online: true     // オンライン状態は維持
            };
        }
        return p;
    });
    
    // 参加者リストを即座に更新
    updateParticipantsList(participantsData);
    
    console.log('自分のマーカー削除完了 - 待機状態に更新');
}

    // === 位置情報送信 ===
    function sendLocationUpdate(position) {
        if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
        
        const normalizedAccuracy = validateAndNormalizeAccuracy(position.coords.accuracy);
        
        const locationData = {
            type: 'location_update',
            participant_id: participantId,
            participant_name: elements.participantName?.value || '',
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: normalizedAccuracy,
            timestamp: new Date().toISOString(),
            is_background: isInBackground
        };
        
        if (position.coords.accuracy > 1000) {
            console.warn('異常な精度値を検出:', position.coords.accuracy, '→ 正常化:', normalizedAccuracy);
        }
        
        websocket.send(JSON.stringify(locationData));
    }

    function sendOfflineStatus() {
        if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
        
        const offlineData = {
            type: 'offline',
            participant_id: participantId,
            participant_name: elements.participantName?.value || '',
            is_background: isInBackground
        };
        
        console.log('オフライン通知を送信:', offlineData);
        websocket.send(JSON.stringify(offlineData));
    }

    // === 位置情報エラーハンドリング ===
    function handleLocationError(error) {
        let message = '';
        switch(error.code) {
            case error.PERMISSION_DENIED:
                message = '位置情報の利用が拒否されました';
                updateStatus('location', 'error', message);
                isSharing = false;
                updateSharingButton();
                break;
            case error.POSITION_UNAVAILABLE:
                message = '位置情報が取得できませんでした';
                updateStatus('location', 'error', message);
                break;
            case error.TIMEOUT:
                message = '位置情報の取得がタイムアウトしました';
                updateStatus('location', 'waiting', message + ' - 再試行中...');
                break;
        }
        console.warn('位置情報エラー:', message, error);
    }

    // === 参加者色管理 ===
    function getDeterministicColor(participantId) {
        let hash = 0;
        for (let i = 0; i < participantId.length; i++) {
            const char = participantId.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        
        const colors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
            '#DDA0DD', '#FFB6C1', '#20B2AA', '#FF69B4', '#32CD32',
            '#FF4500', '#8A2BE2', '#DC143C', '#00CED1', '#FFD700'
        ];
        
        return colors[Math.abs(hash) % colors.length];
    }

    function getParticipantColor(participantId) {
        if (!participantColors[participantId]) {
            participantColors[participantId] = getDeterministicColor(participantId);
        }
        return participantColors[participantId];
    }

    function getInitials(name) {
        if (!name) return 'UN';
        const limitedName = name.substring(0, 30);
        return limitedName.substring(0, 2).toUpperCase();
    }

    // === マップ管理（修正版） ===
    function initMap() {
        map = L.map('map').setView([35.6762, 139.6503], 13);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        
        // ドラッグ操作でのみ追従解除（ズームは除外）
        map.on('dragstart', function() {
            userInteracted = true;
            autoFitEnabled = false;
            followingParticipantId = null;
            console.log('ドラッグ操作により追従を解除しました');
        });

        // ズーム操作では追従は解除しない（autoFitのみ無効化）
        map.on('zoomstart', function() {
            userInteracted = true;
            autoFitEnabled = false;
            console.log('ズーム操作 - 追従は継続、自動調整のみ無効化');
        });

        // マップクリック時の追従解除（マーカー以外をクリックした場合）
        map.on('click', function(e) {
            if (!e.originalEvent.target.closest('.custom-marker')) {
                followingParticipantId = null;
                console.log('マップクリックにより追従を解除しました');
            }
        });
        
        mapInitialized = true;
    }

    function createCustomMarker(name, color) {
        const initials = getInitials(name);
        const markerHtml = `
            <div class="custom-marker" style="background-color: ${color};">
                ${initials}
            </div>
        `;
        
        return L.divIcon({
            html: markerHtml,
            className: 'custom-div-icon',
            iconSize: [40, 40],
            iconAnchor: [20, 45],
            popupAnchor: [0, -40]
        });
    }

    // === マップマーカー更新の修正版 ===
function updateMapMarkers(locations) {
    if (!mapInitialized) return;
    
    const currentMarkerIds = new Set(Object.keys(markers));
    
    // 位置情報が有効な参加者のみをフィルタリング（より厳密な判定）
    const validLocations = locations.filter(loc => {
        const hasValidCoords = loc.latitude !== null && 
                              loc.longitude !== null && 
                              loc.latitude !== 999.0 && 
                              loc.longitude !== 999.0 &&
                              !isNaN(loc.latitude) && 
                              !isNaN(loc.longitude);
        
        // ステータスも考慮
        const isSharing = loc.status === 'sharing';
        
        return hasValidCoords && isSharing;
    });
    
    const newLocationIds = new Set(validLocations.map(loc => loc.participant_id));
    
    // 削除対象：現在のマーカーのうち、有効な位置情報リストに含まれないもの
    const markersToRemove = [...currentMarkerIds].filter(id => !newLocationIds.has(id));
    
    markersToRemove.forEach(id => {
        console.log(`マーカーを削除中: ${id} (共有停止または無効な位置情報)`);
        stopRegularAnimation(id);
        
        if (markers[id]) {
            map.removeLayer(markers[id]);
            delete markers[id];
        }
        
        if (accuracyCircles[id]) {
            map.removeLayer(accuracyCircles[id]);
            delete accuracyCircles[id];
        }
        
        if (animationCircles[id]) {
            map.removeLayer(animationCircles[id]);
            delete animationCircles[id];
        }
    });
    
    // 有効な位置情報のみをキューに追加
    validLocations.forEach(location => {
        markerUpdateQueue.set(location.participant_id, location);
    });
    
    requestAnimationFrame(() => {
        processBatchMarkerUpdates();
        markerUpdateQueue.clear();
    });
}

    // === バッチマーカー更新処理 ===
    function processBatchMarkerUpdates() {
        const locations = Array.from(markerUpdateQueue.values());
        
        locations.forEach(location => {
            const originalName = location.participant_name || `参加者${location.participant_id.substring(0, 4)}`;
            const name = originalName.substring(0, 30);
            const color = getParticipantColor(location.participant_id);
            
            let accuracyText;
            if (!location.accuracy || location.accuracy <= 0) {
                accuracyText = '不明';
            } else if (location.accuracy > 1000) {
                accuracyText = '低精度';
            } else {
                accuracyText = `${Math.round(location.accuracy)}m`;
            }
            
            if (markers[location.participant_id]) {
                const marker = markers[location.participant_id];
                marker.setLatLng([location.latitude, location.longitude]);
                marker.setIcon(createCustomMarker(name, color));
                marker.setPopupContent(`
                    <div style="color: ${color}; font-weight: bold;">${name}</div>
                    <div>最終更新: ${new Date(location.last_updated).toLocaleTimeString()}</div>
                    <div>精度: ${accuracyText}</div>
                `);
                
                // 追従中の場合は現在の位置に移動
                if (followingParticipantId === location.participant_id) {
                    map.setView([location.latitude, location.longitude], map.getZoom());
                    console.log(`追従中の参加者 ${location.participant_id} の位置を更新`);
                }
            } else {
                const customIcon = createCustomMarker(name, color);
                const marker = L.marker([location.latitude, location.longitude], {
                    icon: customIcon
                })
                .addTo(map)
                .bindPopup(`
                    <div style="color: ${color}; font-weight: bold;">${name}</div>
                    <div>最終更新: ${new Date(location.last_updated).toLocaleTimeString()}</div>
                    <div>精度: ${accuracyText}</div>
                `);
                
                // マーカークリック時の追従開始（現在位置で開始）
                marker.on('click', function() {
                    followingParticipantId = location.participant_id;
                    // ズーム操作による自動調整無効化はリセットしない（追従は継続）
                    // userInteracted = false; // この行をコメントアウト
                    // autoFitEnabled = false; // この行もコメントアウト
                    
                    // 現在のマーカー位置に移動（古い位置データではなく）
                    const currentLatLng = marker.getLatLng();
                    map.setView([currentLatLng.lat, currentLatLng.lng], Math.max(map.getZoom(), 15));
                    console.log(`参加者 ${location.participant_id} の追従を開始 (現在位置: ${currentLatLng.lat}, ${currentLatLng.lng})`);
                });
                
                markers[location.participant_id] = marker;
            }
            
            // 精度円の更新
            updateAccuracyCircle(location.participant_id, location.latitude, location.longitude, location.accuracy, color);
            
            // 即座にアニメーションを実行
            createRippleAnimation(location.participant_id, location.latitude, location.longitude, color, location.accuracy);
            
            // 定期アニメーションを開始
            startRegularAnimation(location.participant_id, location.latitude, location.longitude, color, location.accuracy);
        });
        
        // 自動調整（追従中でない場合のみ）
        if (!userInteracted && autoFitEnabled && !followingParticipantId && locations.length > 0) {
            if (locations.length === 1) {
                const loc = locations[0];
                map.setView([loc.latitude, loc.longitude], 15);
            } else {
                const group = new L.featureGroup(Object.values(markers));
                const bounds = group.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds.pad(0.1));
                }
            }
        }
    }

    function updateAccuracyCircle(participantId, latitude, longitude, accuracy, color) {
        // 異常な精度値または無効な値の場合は精度円を表示しない
        if (!accuracy || accuracy <= 0 || accuracy > 1000) {
            if (accuracyCircles[participantId]) {
                map.removeLayer(accuracyCircles[participantId]);
                delete accuracyCircles[participantId];
            }
            return;
        }

        const position = [latitude, longitude];
        
        if (accuracyCircles[participantId]) {
            accuracyCircles[participantId].setLatLng(position);
            accuracyCircles[participantId].setRadius(accuracy);
        } else {
            accuracyCircles[participantId] = L.circle(position, {
                radius: accuracy,
                color: color,
                fillColor: color,
                fillOpacity: 0.1,
                opacity: 0.3,
                weight: 2
            }).addTo(map);
        }
    }

    function createRippleAnimation(participantId, latitude, longitude, color, accuracy) {
        const now = Date.now();
        
        // 既存のアニメーション円があれば削除
        if (animationCircles[participantId]) {
            map.removeLayer(animationCircles[participantId]);
            delete animationCircles[participantId];
        }
        
        // 精度に基づいて最終半径を決定（異常値の場合はデフォルト値使用）
        let maxRadius;
        if (!accuracy || accuracy <= 0 || accuracy > 1000) {
            maxRadius = 50; // デフォルト値
        } else {
            maxRadius = accuracy;
        }
        
        // 新しいアニメーション円を作成
        const animationCircle = L.circle([latitude, longitude], {
            radius: 8,
            color: color,
            fillColor: color,
            fillOpacity: 0.3,
            opacity: 0.8,
            weight: 3
        }).addTo(map);
        
        animationCircles[participantId] = animationCircle;
        
        const duration = 1500;
        const startTime = Date.now();
        const initialRadius = 8;
        
        function animate() {
            const elapsed = Date.now() - startTime;
            const progress = elapsed / duration;
            
            if (progress >= 1) {
                animationCircle.setRadius(maxRadius);
                animationCircle.setStyle({
                    opacity: 0.2,
                    fillOpacity: 0.05,
                    weight: 2
                });
                return;
            }
            
            const easeOut = 1 - Math.pow(1 - progress, 3);
            const currentRadius = initialRadius + (maxRadius - initialRadius) * easeOut;
            const currentOpacity = 0.8 * (1 - progress * 0.75);
            const currentFillOpacity = 0.3 * (1 - progress * 0.83);
            
            animationCircle.setRadius(currentRadius);
            animationCircle.setStyle({
                opacity: currentOpacity,
                fillOpacity: currentFillOpacity,
                weight: Math.max(2, 3 * (1 - progress * 0.33))
            });
            
            requestAnimationFrame(animate);
        }
        
        requestAnimationFrame(animate);
    }

    // === 定期アニメーション開始関数（修正版） ===
    function startRegularAnimation(participantId, latitude, longitude, color, accuracy) {
        // 既存の定期アニメーションがあれば停止
        if (regularAnimationIntervals[participantId]) {
            clearInterval(regularAnimationIntervals[participantId]);
        }
        
        // 3秒間隔で定期的にアニメーション実行
        regularAnimationIntervals[participantId] = setInterval(() => {
            if (markers[participantId]) { // マーカーが存在する場合のみ
                // マーカーの現在位置を取得してアニメーション実行
                const currentLatLng = markers[participantId].getLatLng();
                createRippleAnimation(participantId, currentLatLng.lat, currentLatLng.lng, color, accuracy);
            }
        }, 3000);
    }

    // === 定期アニメーション停止関数 ===
    function stopRegularAnimation(participantId) {
        if (regularAnimationIntervals[participantId]) {
            clearInterval(regularAnimationIntervals[participantId]);
            delete regularAnimationIntervals[participantId];
        }
    }

    // === 参加者リスト管理 ===
    function updateParticipantsList(locations) {
    if (!elements.participantsList) return;
    
    if (locations.length === 0) {
        const emptyHtml = '<div class="text-center text-muted">参加者がいません</div>';
        if (currentParticipantsHtml !== emptyHtml) {
            elements.participantsList.innerHTML = emptyHtml;
            currentParticipantsHtml = emptyHtml;
        }
        return;
    }
    
    // 新規参加者を順序リストに追加
    locations.forEach(location => {
        if (!participantOrder.includes(location.participant_id)) {
            participantOrder.push(location.participant_id);
        }
    });
    
    // 退出した参加者を順序リストから削除
    participantOrder = participantOrder.filter(id => 
        locations.some(location => location.participant_id === id)
    );
    
    participantsData = locations;
    updateParticipantsDisplay();
}
    // === 参加者リスト表示の修正版（追従状態表示付き） ===
    function updateParticipantsDisplay() {
        if (!elements.participantsList || participantsData.length === 0) return;
        
        let html = '';
        
        const sortedLocations = participantOrder.map(id => 
            participantsData.find(location => location.participant_id === id)
        ).filter(location => location !== undefined);
        
        sortedLocations.forEach(location => {
            const isMe = location.participant_id === participantId;
            const isFollowing = followingParticipantId === location.participant_id;
            const lastUpdated = new Date(location.last_updated);
            const timeDiff = Math.floor((new Date() - lastUpdated) / 1000);
            
            let statusClass = '';
            let statusText = '';
            
            // 位置情報が有効かどうかの判定
            const hasValidLocation = location.latitude !== null && 
                                   location.longitude !== null && 
                                   location.latitude !== 999.0 && 
                                   location.longitude !== 999.0 &&
                                   !isNaN(location.latitude) && 
                                   !isNaN(location.longitude);
            
            // ステータス判定ロジック（バックグラウンド状態を考慮）
            if (location.status === 'waiting' && location.is_online) {
                // 待機中かつオンライン
                statusClass = 'status-waiting';
                statusText = isMe ? '共有待機中' : '参加中（未共有）';
            } else if (location.status === 'stopped' || !location.is_online) {
                // 共有停止またはオフライン
                statusClass = 'status-offline';
                if (timeDiff > 300) { // 5分以上
                    statusText = isMe ? 'オフライン（通信エラー）' : 'オフライン（通信エラー）';
                } else {
                    statusText = isMe ? 'オフライン' : 'オフライン';
                }
            } else if (location.status === 'sharing' && hasValidLocation) {
                // 位置情報共有中
                if (location.is_background) {
                    statusClass = 'status-background';
                    statusText = 'バックグラウンド';
                } else if (timeDiff < 120) { // 2分以内
                    statusClass = 'status-online';
                    statusText = 'オンライン';
                } else if (timeDiff < 300) { // 5分以内
                    statusClass = 'status-background';
                    statusText = '一時的にオフライン';
                } else {
                    statusClass = 'status-offline';
                    statusText = 'オフライン（通信エラー）';
                }
            } else {
                // その他の場合（位置情報なしで共有中など、矛盾した状態）
                statusClass = 'status-waiting';
                statusText = isMe ? '状態確認中' : '状態不明';
            }
            
            const color = getParticipantColor(location.participant_id);
            const originalName = location.participant_name || `参加者${location.participant_id.substring(0, 4)}`;
            const name = originalName.substring(0, 30);
            
            let accuracyText;
            if (location.status === 'waiting') {
                accuracyText = isMe ? '位置共有を開始してください' : '位置共有待ち';
            } else if (!hasValidLocation || location.status === 'stopped') {
                accuracyText = '位置情報なし';
            } else if (!location.accuracy || location.accuracy <= 0) {
                accuracyText = '精度: 不明';
            } else if (location.accuracy > 1000) {
                accuracyText = '精度: 低精度';
            } else {
                accuracyText = `精度: ${Math.round(location.accuracy)}m`;
            }
            
            html += `
                <div class="participant-item ${isFollowing ? 'following-participant' : ''}">
                    <div class="status-dot ${statusClass}"></div>
                    <div class="flex-grow-1">
                        <strong style="color: ${color};">${name}</strong>
                        ${isMe ? '<span class="badge bg-primary ms-1">自分</span>' : ''}
                        ${isFollowing ? '<span class="badge bg-info ms-1"><i class="fas fa-crosshairs"></i> 追従中</span>' : ''}
                        <br>
                        <small class="text-muted">
                            ${statusText}
                            <br>
                            ${accuracyText}
                            ${isMe && isInBackground ? ' <span class="badge bg-secondary">BG</span>' : ''}
                        </small>
                    </div>
                </div>
            `;
        });
        
        if (currentParticipantsHtml !== html) {
            elements.participantsList.innerHTML = html;
            currentParticipantsHtml = html;
        }
        
        // 追従状態表示も更新
        updateFollowingStatus();
    }

    // === UI制御（追従状態表示の追加） ===
    function updateSharingButton() {
        if (!elements.toggleSharing) return;
        
        if (isSharing) {
            elements.toggleSharing.innerHTML = '<i class="fas fa-pause"></i> 共有停止';
            elements.toggleSharing.className = 'btn btn-warning';
        } else {
            elements.toggleSharing.innerHTML = '<i class="fas fa-play"></i> 共有開始';
            elements.toggleSharing.className = 'btn btn-success';
        }
        
        // 追従状態の表示更新
        updateFollowingStatus();
    }
// === 追従状態表示の新規追加 ===
    function updateFollowingStatus() {
        // 追従状態を表示する要素があれば更新
        const followingStatus = document.getElementById('following-status');
        if (followingStatus) {
            if (followingParticipantId) {
                const participant = participantsData.find(p => p.participant_id === followingParticipantId);
                const name = participant ? (participant.participant_name || `参加者${followingParticipantId.substring(0, 4)}`) : '不明';
                followingStatus.innerHTML = `<span class="badge bg-info"><i class="fas fa-crosshairs"></i> ${name}を追従中</span>`;
            } else {
                followingStatus.innerHTML = '';
            }
        }
    }

    // === リセット機能の修正 ===
    function resetAutoFit() {
        userInteracted = false;
        autoFitEnabled = true;
        followingParticipantId = null; // 追従も解除
        
        console.log('マップビューをリセット - 追従解除');
        updateFollowingStatus(); // 追従状態表示を更新
        
        const allLayers = [...Object.values(markers), ...Object.values(accuracyCircles)];
        
        if (allLayers.length > 0) {
            if (Object.keys(markers).length === 1) {
                const marker = Object.values(markers)[0];
                const latLng = marker.getLatLng();
                map.setView([latLng.lat, latLng.lng], 15);
            } else {
                const group = new L.featureGroup(allLayers);
                const bounds = group.getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds.pad(0.1));
                }
            }
        }
    }

    function updateCountdown() {
        if (!elements.countdown) return;
        
        const now = new Date();
        const timeLeft = expiresAt - now;
        
        if (timeLeft <= 0) {
            elements.countdown.textContent = '期限切れ';
            handleSessionExpired();
            return;
        }
        
        const hours = Math.floor(timeLeft / (1000 * 60 * 60));
        const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
        
        elements.countdown.textContent = 
            `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // === セッション管理 ===
    function handleSessionExpired() {
        sessionExpired = true;
        stopLocationSharing();
        clearSessionState(); // 期限切れ時は状態をクリア
        
        if (elements.sessionStatus) {
            elements.sessionStatus.innerHTML = '<span class="badge bg-danger">期限切れ</span>';
        }
        
        updateStatus('location', 'error', 'セッションが期限切れです');
        
        const modal = new bootstrap.Modal(document.getElementById('session-expired-modal'));
        modal.show();
    }

    function leaveSession() {
        if (confirm('セッションから退出しますか？')) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const leaveData = {
                    type: 'leave',
                    participant_id: participantId
                };
                websocket.send(JSON.stringify(leaveData));
            }
            
            stopLocationSharing();
            clearSessionState(); // 退出時は状態をクリア
            
            if (websocket) {
                websocket.close();
            }
            
            window.location.href = '/';
        }
    }

    // === 状態復元の改善版 ===
    function restoreSessionState() {
        console.log('セッション状態を復元中...');
        
        const savedState = loadSessionState();
        if (!savedState) {
            console.log('復元する状態がありません');
            return;
        }
        
        // 名前の復元
        if (savedState.participantName && elements.participantName) {
            elements.participantName.value = savedState.participantName;
            sessionState.participantName = savedState.participantName;
            console.log('参加者名を復元:', savedState.participantName);
        }
        
        // 位置情報の復元
        if (savedState.lastPosition) {
            // 模擬的なPositionオブジェクトを作成
            lastKnownPosition = {
                coords: {
                    latitude: savedState.lastPosition.latitude,
                    longitude: savedState.lastPosition.longitude,
                    accuracy: savedState.lastPosition.accuracy
                },
                timestamp: savedState.lastPosition.timestamp
            };
            sessionState.lastPosition = savedState.lastPosition;
            console.log('最後の位置情報を復元:', savedState.lastPosition);
        }
        
        // 共有状態の復元
        if (savedState.isSharing) {
            const timeSinceSharing = Date.now() - (savedState.sharingStartTime || 0);
            if (timeSinceSharing < CONFIG.POSITION_CACHE_DURATION) {
                console.log('位置共有状態を復元中...');
                sessionState.isSharing = true;
                sessionState.sharingStartTime = savedState.sharingStartTime;
                
                // WebSocket接続後に共有を自動開始
                setTimeout(() => {
                    if (!isSharing && !sessionExpired) {
                        console.log('自動的に位置共有を再開');
                        showNotification('前回の共有状態を復元しました', 'info');
                        startLocationSharing();
                    }
                }, 3000); // WebSocket接続完了を待つ
            } else {
                console.log('共有状態が古いため復元しません');
                clearSessionState();
            }
        }
    }

    // === 初期化（修正版） ===
    document.addEventListener('DOMContentLoaded', function() {
    console.log('アプリケーション初期化開始');
    
    initElements();
    initMap();
    
    // 状態復元を実行
    restoreSessionState();
    
    // WebSocket接続を少し遅らせて安定化
    setTimeout(initWebSocket, 1000);
    
    // イベントリスナー設定
    if (elements.toggleSharing) {
        addEventListenerWithCleanup(elements.toggleSharing, 'click', function() {
            if (isSharing) {
                stopLocationSharing();
            } else {
                const modal = new bootstrap.Modal(document.getElementById('permission-modal'));
                modal.show();
            }
        });
    }
    
    const resetViewBtn = document.getElementById('reset-view');
    if (resetViewBtn) {
        addEventListenerWithCleanup(resetViewBtn, 'click', resetAutoFit);
    }
    
    const leaveSessionBtn = document.getElementById('leave-session');
    if (leaveSessionBtn) {
        addEventListenerWithCleanup(leaveSessionBtn, 'click', leaveSession);
    }
    
    // 権限要求ボタンの適切な処理
    const requestLocationBtn = document.getElementById('request-location');
    if (requestLocationBtn) {
        addEventListenerWithCleanup(requestLocationBtn, 'click', function() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('permission-modal'));
            if (modal) {
                modal.hide();
            }
            startLocationSharing();
        });
    }
    
    // onclick属性のあるボタンの修正
    const requestLocationButtons = document.querySelectorAll('[onclick*="requestLocation"]');
    requestLocationButtons.forEach(button => {
        button.removeAttribute('onclick');
        addEventListenerWithCleanup(button, 'click', function() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('permission-modal'));
            if (modal) {
                modal.hide();
            }
            startLocationSharing();
        });
    });
    
    // 名前変更監視をセットアップ
    setupNameChangeListener();
    
    // ページ可視性変更ハンドラーをセットアップ
    setupVisibilityChangeHandler();
    
    // 定期処理
    setInterval(updateCountdown, 1000);
    setInterval(updateParticipantsDisplay, CONFIG.PARTICIPANTS_UPDATE);
    
    // 定期的な状態保存
    setInterval(() => {
        if (isSharing) {
            saveSessionState();
        }
    }, 30000); // 30秒間隔
    
    updateCountdown();
    updateStatus('visibility', 'active', 'アクティブ');
    
    console.log('アプリケーション初期化完了 - 即時反映システム有効');
});

    // === クリーンアップ（修正版） ===
    window.addEventListener('beforeunload', function(e) {
    console.log('ページ離脱前の処理');
    
    // 現在の状態を保存
    if (isSharing) {
        saveSessionState();
        sendOfflineStatus(); // 全参加者に即座に反映
    }
    
    // 全てのリソースをクリーンアップ
    stopConnectionManagement();
    stopBackgroundLocationUpdate();
    
    if (locationInterval) clearInterval(locationInterval);
    
    // 全ての定期アニメーションを停止
    Object.keys(regularAnimationIntervals).forEach(id => {
        stopRegularAnimation(id);
    });
    
    // イベントリスナーのクリーンアップ
    cleanupEventListeners();
    
    // マーカーとサークルのクリーンアップ
    if (mapInitialized) {
        Object.values(markers).forEach(marker => map.removeLayer(marker));
        Object.values(accuracyCircles).forEach(circle => map.removeLayer(circle));
        Object.values(animationCircles).forEach(circle => map.removeLayer(circle));
    }
    
    if (websocket) {
        websocket.close();
    }
});

    // === ページ可視性管理の修正版 ===
function setupVisibilityChangeHandler() {
    document.addEventListener('visibilitychange', function() {
        const wasInBackground = isInBackground;
        isInBackground = document.hidden;
        
        console.log(`可視性変更: ${wasInBackground ? 'BG' : 'FG'} → ${isInBackground ? 'BG' : 'FG'}, 共有中: ${isSharing}`);
        
        if (!isInBackground && wasInBackground) {
            console.log('フォアグラウンドに復帰 - 接続状態を確認中');
            updateStatus('visibility', 'active', 'アクティブ');
            
            // 再接続試行回数をリセット
            backgroundReconnectAttempts = 0;
            
            // WebSocket接続チェック
            if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                console.log('フォアグラウンド復帰時にWebSocket再接続');
                setTimeout(initWebSocket, 1000);
            } else {
                // 状態同期確認（特に共有停止状態の場合）
                if (!isSharing) {
                    console.log('フォアグラウンド復帰時の共有停止状態確認');
                    setTimeout(() => {
                        if (websocket && websocket.readyState === WebSocket.OPEN && !isSharing) {
                            const syncData = {
                                type: 'sync_status',
                                participant_id: participantId,
                                participant_name: elements.participantName?.value || '',
                                is_sharing: false,
                                status: 'waiting',
                                is_background: false
                            };
                            websocket.send(JSON.stringify(syncData));
                            console.log('共有停止状態の同期確認を送信');
                        }
                    }, 1000);
                }
            }
            
        } else if (isInBackground && !wasInBackground) {
            console.log('バックグラウンドに移行');
            updateStatus('visibility', 'background', 'バックグラウンド');
        }
        
        // WebSocketが接続中の場合は可視性変更を通知
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            const statusData = {
                type: 'background_status_update',
                participant_id: participantId,
                participant_name: elements.participantName?.value || '',
                is_background: isInBackground,
                has_position: !!lastKnownPosition,
                is_sharing: isSharing,
                timestamp: new Date().toISOString()
            };
            
            try {
                websocket.send(JSON.stringify(statusData));
                console.log(`バックグラウンド状態変更を送信: ${isInBackground ? 'BG' : 'FG'}, 共有: ${isSharing}`);
            } catch (error) {
                console.warn('バックグラウンド状態変更通知の送信に失敗:', error);
            }
        }
    });
}
    // === 名前変更リスナーの修正版 ===
function setupNameChangeListener() {
    if (elements.participantName) {
        let nameUpdateTimeout;
        addEventListenerWithCleanup(elements.participantName, 'input', function() {
            let newName = this.value.trim();
            if (newName.length > 30) {
                newName = newName.substring(0, 30);
                this.value = newName;
            }
            
            // 自分のマーカー即座更新
            if (markers[participantId]) {
                const color = getParticipantColor(participantId);
                const customIcon = createCustomMarker(newName || `参加者${participantId.substring(0, 4)}`, color);
                markers[participantId].setIcon(customIcon);
            }
            
            // 状態を保存
            sessionState.participantName = newName;
            saveSessionState();
            
            // デバウンス処理でWebSocket送信頻度を制限
            clearTimeout(nameUpdateTimeout);
            nameUpdateTimeout = setTimeout(() => {
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    const nameUpdateData = {
                        type: 'name_update',
                        participant_id: participantId,
                        participant_name: newName
                    };
                    websocket.send(JSON.stringify(nameUpdateData));
                    console.log('名前変更を送信 - 全参加者に即座に反映されます');
                }
            }, 500);
        });
    }
}
    // === ユーティリティ関数 ===
    function requestLocation() {
        const modal = bootstrap.Modal.getInstance(document.getElementById('permission-modal'));
        if (modal) {
            modal.hide();
        }
        startLocationSharing();
    }
    
    function goToHome() {
        window.location.href = '/';
    }

    // === 精度値の検証と正常化 ===
    function validateAndNormalizeAccuracy(accuracy) {
        if (!accuracy || accuracy <= 0 || accuracy > 1000) {
            return null;
        }
        return Math.round(accuracy);
    }

    // === 位置情報の品質チェック ===
    function assessLocationQuality(position) {
        const accuracy = position.coords.accuracy;
        
        if (!accuracy || accuracy <= 0) {
            return { quality: 'unknown', message: '精度情報なし' };
        } else if (accuracy <= 5) {
            return { quality: 'excellent', message: '非常に高精度' };
        } else if (accuracy <= 20) {
            return { quality: 'good', message: '高精度' };
        } else if (accuracy <= 100) {
            return { quality: 'fair', message: '中程度の精度' };
        } else if (accuracy <= 1000) {
            return { quality: 'poor', message: '低精度' };
        } else {
            return { quality: 'very_poor', message: '極めて低い精度' };
        }
    }

    // === 距離計算 ===
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // 地球の半径（メートル）
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    // === 移動検知による送信判定 ===
    function shouldSendUpdate(position) {
        const now = Date.now();
        
        // 最小送信間隔チェック
        if (now - lastSentTime < CONFIG.MIN_TIME_BETWEEN_UPDATES) {
            return false;
        }
        
        // 初回送信または前回位置がない場合
        if (!lastSentPosition) {
            return true;
        }
        
        // 移動距離を計算
        const distance = calculateDistance(
            lastSentPosition.coords.latitude,
            lastSentPosition.coords.longitude,
            position.coords.latitude,
            position.coords.longitude
        );
        
        // 移動閾値を超えた場合
        if (distance >= CONFIG.MOVEMENT_THRESHOLD) {
            return true;
        }
        
        // 最大無送信時間を超えた場合（生存確認）
        if (now - lastSentTime >= CONFIG.MAX_TIME_WITHOUT_UPDATE) {
            return true;
        }
        
        return false;
    }
</script>
{% endblock %}